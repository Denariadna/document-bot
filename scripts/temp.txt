у меня почему то при отправлении продюсера в реббит, он не может отправить ccorrelation_id как его и откуда получить (вообще он генериться но не понятно откуда и как то настроить) консюмер не видит correlation_id что делать??

вот файлы конфигурации л

моя цель создать бот для хранения документов, тоесть пользователь сохраняет у меня файлы а потом может получить их обратно

в общем передомной стоит задача разделить сервис (который находиться в src) , и создать дополнительный сервис consumer, нужно вынести работу с посгрис (а также частично работу с минио, тольлько выгрузку файлов и потом от туда же кидать в бота) все это должно быть настроенно через rebbitMQ,  я скину тебе код, вначале того что в src (это рабочий код но только на одном серевеере работает нужно отключить сервер, потом того что в консюмере (то что в консюмере это пример другого проекта, но нужно примерно такое только с моей задачей)

src/storege/rebbit (используем для подключений к реббиту)
import aio_pika
from aio_pika import Channel, connect_robust
from aio_pika.abc import AbstractRobustConnection
from aio_pika.pool import Pool

from typing import cast

from config.settings import settings


async def get_connection() -> AbstractRobustConnection:
    return await aio_pika.connect_robust(settings.rabbit_url)

connection_pool: Pool[AbstractRobustConnection] = Pool(get_connection, max_size=2)


async def get_channel() -> Channel:
    async with connection_pool.acquire() as connection:
        return cast(Channel, await connection.channel())


channel_pool: Pool[Channel] = Pool(get_channel, max_size=10)

minio_client.py
from minio import Minio
from minio.error import S3Error
from config.settings import settings
from io import BytesIO

# Инициализация Minio клиента
minio_client = Minio(
    settings.MINIO_URL.replace("http://", "").replace("https://", ""),
    access_key=settings.MINIO_ACCESS_KEY,
    secret_key=settings.MINIO_SECRET_KEY,
    secure=False,
)

def create_bucket() -> None:
    """
    Создает бакет, если он не существует.
    """
    if not minio_client.bucket_exists(settings.MINIO_BUCKET_NAME):
        minio_client.make_bucket(settings.MINIO_BUCKET_NAME)

def upload_file(user_id: int, file_name: str, file_data: bytes) -> str:
    """
    Загружает файл в MinIO.

    Args:
        user_id (int): ID пользователя.
        file_name (str): Имя файла.
        file_data (bytes): Данные файла.

    Returns:
        str: Уникальное имя файла в бакете.
    """
    unique_name = f"{user_id}_{file_name}"
    # Оборачиваем данные в BytesIO
    file_stream = BytesIO(file_data)
    minio_client.put_object(
        bucket_name=settings.MINIO_BUCKET_NAME,
        object_name=unique_name,
        data=file_stream,
        length=len(file_data),
        content_type="application/octet-stream"
    )
    return unique_name

def get_file_path(file_name: str) -> str:
    """
    Возвращает временный URL для доступа к файлу.

    Args:
        file_name (str): Имя файла в бакете.

    Returns:
        str: Подписанный URL для доступа к файлу.
    """
    return minio_client.presigned_get_object(settings.MINIO_BUCKET_NAME, file_name)

async def download_file(minio_path: str, local_path: str) -> None:
    """Скачивает файл из MinIO."""
    minio_client.fget_object(settings.MINIO_BUCKET_NAME, minio_path, local_path)

src/handlers/command/file (нужно будет логику которая отвечает за работу с постгрисом поменять и настроить так чтобы эта задача пошла в консумер, незнаю как лучше ну ты придумай что нибудь)
from aiogram import types
from aiogram.fsm.context import FSMContext
from sqlalchemy.future import select
from src.storage.minio_client import upload_file
from src.storage.db import async_session
from src.model.file import FileRecord
from src.logger import logger  # Импорт логгера
from src.handlers.states.file import FileStates

async def initiate_upload(message: types.Message, state: FSMContext) -> None:
    if message.from_user is None:
        logger.error("Ошибка: сообщение не содержит информации об отправителе (from_user = None).")
        return

    # Устанавливаем состояние через FSMContext
    await state.set_state(FileStates.waiting_for_file)
    await message.reply("Отправьте файл, который хотите загрузить.")


async def check_state(message: types.Message, state: FSMContext) -> None:
    current_state = await state.get_state()
    await message.reply(f"Текущее состояние: {current_state or 'Нет состояния'}")

async def show_files(message: types.Message) -> None:
    """Показать файлы пользователя."""
    from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup



    if message.from_user is None:
        logger.error("Ошибка: сообщение не содержит информации об отправителе (from_user = None).")
        return

    user_id = message.from_user.id
    async with async_session() as db:
        result = await db.execute(
            select(FileRecord.file_name).where(FileRecord.user_id == user_id)
        )
        files = result.scalars().all()

    logger.info("Пользователь загрузил следующие файлы: %s", files)

    if not files:
        await message.reply("У вас нет загруженных файлов.")
        return

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=file, callback_data=f"file:{file}")]
            for file in files
        ]
    )
    
    await message.reply("Ваши файлы:", reply_markup=keyboard)

src/hendlers/command/start (здесь нужно как я понимаю настраивать подключение к QUEUE 
примерный код)
@router.message(Command('start'))
async def start_cmd(message: Message, state: FSMContext) -> None:
    await state.set_data({})
    await state.get_data()

    await state.set_state(AuthGroup.authorized)
    await state.get_state()
    async with channel_pool.acquire() as channel:  # type: aio_pika.Channel
        exchange = await channel.declare_exchange("user_gifts", ExchangeType.TOPIC, durable=True)

        queue = await channel.declare_queue(
            settings.USER_GIFT_QUEUE_TEMPLATE.format(
                user_id=message.from_user.id,
            ),
            durable=True,
        )

        users_queue = await channel.declare_queue(
            'user_messages',
            durable=True,
        )

        # Binding queue
        await queue.bind(
            exchange,
            settings.USER_GIFT_QUEUE_TEMPLATE.format(
                user_id=message.from_user.id,
            ),
        )
        # Binding queue
        await users_queue.bind(
            exchange,
            'user_messages'
        )

        await exchange.publish(
            aio_pika.Message(
                msgpack.packb(
                    GiftMessage(
                        user_id=message.from_user.id,
                        action='get_gifts',
                        event='gift'
                    )
                ),
                # correlation_id=context.get(HeaderKeys.correlation_id)
            )
            ,
            'user_messages'
        )

тот код который есть сейчас
from aiogram import types
import logging
logger = logging.getLogger(__name__)

# Функция обработки команды /start
async def start(message: types.Message) -> None:
    await message.reply("Урааааааа")

# функция обработки команды /help
async def help_command(message: types.Message)-> None:
    commands = (
        "/start - начать работу с ботом",
        "/help - показать доступные команды",
        "/upload - загрузить файл",
        "/show_files - скачать файл",
        "/check_state - проверить состояние"
    )
    await message.reply("\n".join(commands))

# Функция, которая просто повторяет сообщение пользователя
async def echo(message: types.Message) -> None:
    logger.info(f"Получено сообщение: {message.text}")
    if message.text:
        await message.answer(message.text)
    else:
        logger.warning("Сообщение не содержит текста.")
        await message.answer("Пожалуйста, отправьте текстовое сообщение.")

src/handlers/callback/file
@router.message(Command('start'))
async def start_cmd(message: Message, state: FSMContext) -> None:
    await state.set_data({})
    await state.get_data()

    await state.set_state(AuthGroup.authorized)
    await state.get_state()
    async with channel_pool.acquire() as channel:  # type: aio_pika.Channel
        exchange = await channel.declare_exchange("user_gifts", ExchangeType.TOPIC, durable=True)

        queue = await channel.declare_queue(
            settings.USER_GIFT_QUEUE_TEMPLATE.format(
                user_id=message.from_user.id,
            ),
            durable=True,
        )

        users_queue = await channel.declare_queue(
            'user_messages',
            durable=True,
        )

        # Binding queue
        await queue.bind(
            exchange,
            settings.USER_GIFT_QUEUE_TEMPLATE.format(
                user_id=message.from_user.id,
            ),
        )
        # Binding queue
        await users_queue.bind(
            exchange,
            'user_messages'
        )

        await exchange.publish(
            aio_pika.Message(
                msgpack.packb(
                    GiftMessage(
                        user_id=message.from_user.id,
                        action='get_gifts',
                        event='gift'
                    )
                ),
                # correlation_id=context.get(HeaderKeys.correlation_id)
            )
            ,
            'user_messages'
        )

src/api/minio/minio
from fastapi import HTTPException, Query
from fastapi.responses import FileResponse
from src.storage.minio_client import download_file, get_file_path
from src.storage.db import async_session
from src.model.file import FileRecord
from sqlalchemy.future import select
from src.logger import logger
from .router import router

@router.get("/get-file", summary="Скачать файл")
async def get_file(
    user_id: int = Query(..., description="ID пользователя"),
    file_name: str = Query(..., description="Имя файла")
) -> FileResponse:
    """
    Скачивает файл из MinIO и возвращает его.

    Args:
        user_id (int): ID пользователя.
        file_name (str): Имя файла.

    Returns:
        FileResponse: Файл для скачивания.
    """
    # Поиск записи файла в базе данных
    async with async_session() as db:
        result = await db.execute(
            select(FileRecord).where(FileRecord.user_id == user_id, FileRecord.file_name == file_name)
        )
        file_record = result.scalar_one_or_none()

    if file_record is None:
        logger.error("Файл не найден в базе данных.")
        raise HTTPException(status_code=404, detail="Файл не найден.")

    # Получаем путь к файлу в MinIO
    minio_path = file_record.file_path
    local_path = f"/tmp/{file_name}"

    # Скачиваем файл из MinIO
    try:
        await download_file(minio_path, local_path)
        logger.info(f"Файл {file_name} скачан из MinIO.")
    except Exception as e:
        logger.error(f"Ошибка при скачивании файла: {e}")
        raise HTTPException(status_code=500, detail="Ошибка при скачивании файла.")

    # Возвращаем файл пользователю
    return FileResponse(local_path, filename=file_name)


(настрой вначале код в src, а потом перейдем, к настройке consumer)

app.py
import logging.config

import aio_pika
import msgpack

from consumer.handlers.gift import handle_event_gift
from consumer.logger import LOGGING_CONFIG, logger, correlation_id_ctx
from consumer.metrics import TOTAL_RECEIVED_MESSAGES
from consumer.schema.gift import GiftMessage
from consumer.storage import rabbit


async def start_consumer() -> None:
    logging.config.dictConfig(LOGGING_CONFIG)
    logger.info('Starting consumer...')

    queue_name = "test_queue"
    async with rabbit.channel_pool.acquire() as channel:  # type: aio_pika.Channel

        # Will take no more than 10 messages in advance
        await channel.set_qos(prefetch_count=10) # TODO почитать

        # Declaring queue
        queue = await channel.declare_queue(queue_name, durable=True)

        logger.info('Consumer started!')
        async with queue.iterator() as queue_iter:
            async for message in queue_iter: # type: aio_pika.Message
                TOTAL_RECEIVED_MESSAGES.inc()
                async with message.process():  # после выхода из with будет ack (есть еще no_ack)
                    correlation_id_ctx.set(message.correlation_id)

                    body: GiftMessage = msgpack.unpackb(message.body)
                    logger.info("Message: %s", body)

                    if body.get('event') == 'gift':
                        await handle_event_gift(body)


# Возможно более понятный код вида консмура
# queue: Queue
# while True:
#     message = await queue.get()
#     async with message.process():  # после выхода из with будет ack (есть еще no_ack)
#         correlation_id_ctx.set(message.correlation_id)
#         logger.info("Message ...")
#
#         body: GiftMessage = msgpack.unpackb(message.body)
#         if body['event'] == 'gift':
#             await handle_event_gift(body)


web_app.py
import asyncio
import logging
import asyncio
import time
from typing import AsyncGenerator


from contextlib import asynccontextmanager
from fastapi import FastAPI

from consumer.api.tech.router import router as tech_router
from consumer.app import start_consumer
from consumer.logger import logger, LOGGING_CONFIG


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    logging.config.dictConfig(LOGGING_CONFIG)

    logger.info('Starting lifespan')
    task = asyncio.create_task(start_consumer())

    logger.info('Started succesfully')
    yield

    if task is not None:
        logger.info("Stopping polling...")
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            logger.info("Polling stopped")

    logger.info('Ending lifespan')


def create_app() -> FastAPI:
    app = FastAPI(docs_url='/swagger', lifespan=lifespan)
    app.include_router(tech_router, prefix='', tags=['tech'])
    return app

__main__.py
import uvicorn


if __name__ == '__main__':
    uvicorn.run('consumer.web_app:create_app', factory=True, host='0.0.0.0', port=8010, workers=1)

rabbit.py
import aio_pika
from aio_pika.abc import AbstractRobustConnection
from aio_pika.pool import Pool

from config.settings import settings


async def get_connection() -> AbstractRobustConnection:
    return await aio_pika.connect_robust(settings.rabbit_url)

connection_pool: Pool = Pool(get_connection, max_size=2)


async def get_channel() -> aio_pika.Channel:
    async with connection_pool.acquire() as connection:
        return await connection.channel()


channel_pool: Pool = Pool(get_channel, max_size=10)


async def get_connection() -> AbstractRobustConnection:
    return await aio_pika.connect_robust("amqp://guest:guest@localhost/")

пример обработчика
# import random

# import aio_pika
# import msgpack
# from aio_pika import ExchangeType
# from sqlalchemy import select, func

# from config.settings import settings
# from consumer.logger import correlation_id_ctx
# from consumer.model.gift import Gift
# from consumer.schema.gift import GiftMessage
# from consumer.storage import rabbit, db


# async def handle_event_gift(message: GiftMessage):
#     if message['action'] == 'get_gifts':
#         async with db.async_session() as db_session:
#             # gifts = (await db.scalars(select(Gift).order_by(func.random()))).all()

#             not_fetched = await db_session.execute(select(Gift).order_by(func.random()))
#             tuple_rows = not_fetched.all()
#             gifts = [row for row, in tuple_rows]

#             async with rabbit.channel_pool.acquire() as channel:  # type: aio_pika.Channel
#                 exchange = await channel.declare_exchange("user_gifts", ExchangeType.TOPIC, durable=True)

#                 for gift in gifts:
#                     await exchange.publish(
#                         aio_pika.Message(
#                             msgpack.packb({
#                                 'name': gift.name,
#                                 'photo': gift.photo,
#                                 'category': gift.category,
#                             }),
#                             correlation_id=correlation_id_ctx.get(),
#                         ),
#                         routing_key=settings.USER_GIFT_QUEUE_TEMPLATE.format(user_id=message['user_id']),
#                     )


нужно сделать в консумере перенести почти все мои функции кроме того что файлы класть файл в минио при команде upload, я буду всеже  в продюсере, но всеравно когда информация что файл положился в минио прийдет, необходимо куинуть в очередь информацию для создания записи в посгриес